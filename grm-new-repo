#!/usr/bin/perl
use strict;
use feature 'say';
use File::Basename qw(basename);
use Cwd qw(cwd getcwd);
use IPC::Open3 qw(open3);

sub run_sync_redir;
sub indir;

our $myPath = $0;
our $myName = basename($myPath);

our $config = {};

# Overlay environment variables
foreach my $envKey (keys %ENV) {
	if ($envKey =~ /^GRM_(.+)$/) {
		my $configKey = $1;
		$config->{$configKey} = $ENV{$envKey};
	}
}

# Check required environment variables
my @required_vars = qw(CONFIG_CMD RPATH_TEMPLATE RLOGIN RPATH_BASE);
my @missing;

foreach my $var (@required_vars) {
	push @missing, "GRM_$var" unless defined $config->{$var};
}

if (@missing) {
	say "Creation of new remotes requires the following configuration items to be set: ".join(' ', @missing);
	exit 2;
}

# Ensure RLOGIN has valid protocol if set, or act as if it were ssh://localhost if blank
my $ssh_host;
my $effective_login;

if (!length($config->{RLOGIN})) {
    # Act as if using localhost via SSH if RLOGIN is blank
    $ssh_host = 'localhost';
    # Use ssh://localhost internally without modifying config
    $effective_login = 'ssh://localhost';
} elsif ($config->{RLOGIN} =~ /^ssh:\/\/(.+)$/) {
    # RLOGIN has SSH protocol prefix - extract the host part for SSH command
    $ssh_host = $1;
    $effective_login = $config->{RLOGIN};
} else {
    say "Error: RLOGIN must be in format 'ssh://[user@]host' for SSH remote creation";
    exit 3;
}

# Determine whether this dir is already a git repo
my $VIRGIN = !(-d '.git');

# Run grm commands to get path information
my $LREL = `grm list-lrel`;
chomp $LREL;
my $RREL = `grm list-rrel`;
chomp $RREL;

my $GRM_RPATH = "$config->{RPATH_BASE}/$RREL";
$GRM_RPATH .= '.git' unless $GRM_RPATH =~ /\.git$/;

# There must be exactly one GRM-known (sub)directory and it must be .
if ($RREL eq '' || getcwd() !~ /$LREL$/) {
	say 'The current directory is unknown to GRM!';
	exit 1;
}

# Prompt for confirmation
print "About to create remote repo '$GRM_RPATH'; are you sure? ";
my $reply = <STDIN>;
chomp $reply;

if ($reply !~ /^[Yy]$/) {
	say "(aborted)";
	exit 0;
}

# Create new remote repo based on remote template
if ($effective_login =~ /^ssh:\/\/(.+)$/) {
    my $ssh_cmd = "xargs -0 -n 1 -- cp -na --reflink=auto '$config->{RPATH_BASE}/$config->{RPATH_TEMPLATE}'";
    my $pid_ssh;

    eval {
        $pid_ssh = open3(my $ssh_in, '>&STDERR', '>&STDERR', 'ssh', $ssh_host, $ssh_cmd);
        print $ssh_in "$GRM_RPATH\0";
        close $ssh_in;
    };

    die "$myName: failed to create remote repository"
        unless $pid_ssh;

    waitpid($pid_ssh, 0);
    die "$myName: remote repository creation failed"
        if $?;
}

# Initialize git repository
die "$myName: git init failed"
	if run_sync_redir qw(git init -q);

# Configure the repository
die "$myName: config command failed"
	if run_sync_redir $config->{CONFIG_CMD};

# Git remote URL
my $GIT_REMOTE = $effective_login.$GRM_RPATH;

# Check if remote exists, add or update it accordingly
my $remote_exists = system('git remote get-url origin >/dev/null 2>&1') == 0;

if ($remote_exists) {
	# Remote exists, update it
	die "$myName: failed to update remote URL"
		if run_sync_redir qw(git remote set-url origin), $GIT_REMOTE;
		
	die "$myName: git fetch failed"
		if run_sync_redir qw(git fetch origin);
} else {
	# Remote doesn't exist, add it
	die "$myName: failed to add remote"
		if run_sync_redir qw(git remote add -f origin), $GIT_REMOTE;
}

# Checkout master if this was a new repository
if ($VIRGIN) {
	die "$myName: git checkout failed"
		if run_sync_redir qw(git checkout master);
}

exit 0;

########################################################################################################################

sub run_sync_redir(@)
{
	my $pid;
	eval {
		$pid = open3(undef, '>&STDERR', '>&STDERR', @_);
	};
	
	die "$myName: failed to run {@_}"
		unless $pid;
	
	waitpid($pid, 0);
	return $?;
}

sub indir ($&)
{
	my $dir = shift @_;
	my $code = \&{shift @_};

	my $orig = cwd;
	chdir($dir);
	my $result = $code->();
	chdir($orig);
	return $result;
}