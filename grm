#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Cwd qw(cwd getcwd);

our $myPath = $0;
our $myName = basename($myPath);

our $fnList = '.remotes';

our $childPrefix = $ENV{'GMC_RECURSE_PREFIX'} // '';

die "$myName: too many arguments\n" unless scalar @ARGV == 0;

our $config = {
	OPT_RECURSE => 1,
	CONFIG_CMD => '',
	REMOTE_DIR => '',
	LOCAL_DIR => '.',
	GM_DIR => undef,
};

our $treeFilter = cwd; # Save current directory so we can use it later
&chdir_find_listfile;  # Change to the nearest ancestor dir containing a listfile

open (my $fh, '<', $fnList) or exit 0;
while (<$fh>){
    chomp;

    s/#.*$//;        # Remove comments (can be suffix)
    next if /^\s*$/; # Skip lines of pure whitespace
    s/\s+$//;        # Remove trailing whitespace (can happen after stripping inline comments)

    my ($REMOTE_REL, $LOCAL_REL, $GM_REL) = split /:/, $_, 3;
    $REMOTE_REL = '' unless defined ($REMOTE_REL);
    $LOCAL_REL = '' unless defined ($LOCAL_REL);
    $GM_REL = '' unless defined ($GM_REL);

	if ($REMOTE_REL eq '') {
		$config->{$LOCAL_REL} = $GM_REL;
		next;
	}

    $LOCAL_REL = $REMOTE_REL unless ($LOCAL_REL ne '');
	$GM_REL = $REMOTE_REL unless ($GM_REL ne '');

	my $remotePath = &cat_path($config->{REMOTE_DIR}, $REMOTE_REL);
	my $localPath  = &cat_path($config->{LOCAL_DIR }, $LOCAL_REL );
	my $mediaPath  = &cat_path($config->{GM_DIR    }, $GM_REL    );

	die "$myName: '$childPrefix$fnList' does not define REMOTE_BASE_URL\n"
		unless defined $config->{REMOTE_BASE_URL};

	&repo_process($localPath, $remotePath, $mediaPath)
		if catfile(cwd, $localPath) =~ /\Q$treeFilter\E(?:\/.+)?$/; # Skip items outside the tree we were run in
}

&recurse($treeFilter) if $config->{OPT_RECURSE};

exit 0;

########################################################################################################################

sub cat_path {
	my @pieces = grep {defined $_ and $_ ne ''} @_;

	my $result = undef;
	for my $piece (reverse @pieces) {
		$piece =~ s/^\.\///;
		if (not defined $result) {
			$result=$piece;
		}
		else {
			$result = "$piece/$result";
		}

		return $result if $piece =~ /^\//;
	}

	return $result;	
}

sub chdir_find_listfile {
	until (-e $fnList) {
		my $prev = cwd;

		die "$myName: no '$childPrefix$fnList' file found in current directory or any ancestor\n"
			unless chdir('..') and cwd ne $prev;
	}
}

sub is_dir_repo_root {
	my ($localPath) = @_;

	my $prefix = `cd "$localPath" && git rev-parse --show-prefix`;

	die "$myName: is_dir_repo_root failed\n"
		if $?;

	chomp $prefix;
	return $prefix eq '';
}

sub repo_process {
	my ($localPath, $remotePath, $mediaPath) = @_;

	if (-e $localPath) {
		unless (-d $localPath) {
			# Flag non-dirs that block repos
			print STDERR "ERROR: '$childPrefix$localPath' is not a directory\n";
			next;
		}

		# Don't touch non-repo dirs with a bargepole
		unless (&is_dir_repo_root($localPath)) {
			print STDERR "ERROR: '$childPrefix$localPath' is not a Git repository\n";
			return;
		}

		# Don't clone but update remote & configure
		print STDERR "'$childPrefix$localPath' exists\n";
		&repo_set_remote($localPath, "$config->{REMOTE_BASE_URL}/$remotePath");
		&repo_config($localPath, $mediaPath);
	}
	else {
		# We need to configure after clone but before checkout, thus the three steps
		&repo_clone_nocheckout($localPath, "$config->{REMOTE_BASE_URL}/$remotePath");
		&repo_config($localPath, $mediaPath);
		&repo_check_out($localPath);
	}
}

sub repo_clone_nocheckout {
	my ($localPath, $remotePath) = @_;

	die "$myName: cloning failed for '$childPrefix$localPath'\n"
		if system qq!git clone --no-checkout "$remotePath" "$localPath" 1>&2!;
}

sub repo_config {
    my ($localPath, $mediaPath) = @_;

	$mediaPath = '' unless defined $mediaPath;

	die "$myName: configuration failed for '$childPrefix$localPath'\n"
		if $config->{CONFIG_CMD} and system qq!cd "$localPath" && $config->{CONFIG_CMD} "$mediaPath" 1>&2!;
}

sub repo_check_out {
	my ($localPath) = @_;

	die "$myName: checkout failed for '$childPrefix$localPath'\n"
		if system qq!cd "$localPath" && git reset --hard 1>&2!;
}

sub repo_set_remote {
	my ($localPath, $remotePath) = @_;

	system qq!cd "$localPath" && git remote set-url origin "$remotePath" 1>&2!
		and die "$myName: configuration failed for '$childPrefix$localPath'\n";
}

sub recurse {
    my ($dir) = @_;
	$dir =~ s/\/$//; # Remove any trailing slash before concatenating

	die "$myName: cannot open directory '$dir'\n"
		unless opendir(my $handle, $dir);

	my @kids = readdir($handle);

	foreach my $kid (@kids) {
		my $kidPath = cat_path($dir, $kid);
		next if (not -d $kidPath);

		next if $kid =~ /^\./;

		if (-e "$kidPath/$fnList") { # Subdirs containing listfiles need recursive invocation
			my $kidPathRel  =  $kidPath =~ s/^$treeFilter\///r;

			system qq!cd "$kidPath" && GMC_RECURSE_PREFIX="$kidPathRel/" "$myPath"!;
			next; # Recursion will have found any deeper listfiles, so bail on this dir
		}

		&recurse($kidPath);
	}

	closedir($handle);
}