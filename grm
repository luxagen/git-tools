#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Cwd qw(cwd getcwd);
use File::Spec::Functions qw(catfile);

our $myPath = $0;
our $myName = basename($myPath);

our $fnList = '.remotes';

our $childPrefix = $ENV{'GMC_RECURSE_PREFIX'} // '';

die "$myName: too many arguments\n" unless scalar @ARGV == 0;

our $config = {
	OPT_RECURSE => 1,
	CONFIG_CMD => '',
	REMOTE_DIR => '',
	LOCAL_DIR => '.',
	GM_DIR => undef,
};

our $treeFilter = cwd; # Save current directory so we can use it later
&chdir_find_listfile;  # Change to the nearest ancestor dir containing a listfile

open (my $fh, '<', $fnList) or exit 0;
while (<$fh>){
    chomp;

    s/#.*$//;        # Remove comments (can be suffix)
    next if /^\s*$/; # Skip lines of pure whitespace
    s/\s+$//;        # Remove trailing whitespace (can happen after stripping inline comments)

    my ($REMOTE_REL, $LOCAL_REL, $GM_REL) = split /:/, $_, 3;
    $REMOTE_REL = '' unless defined ($REMOTE_REL);
    $LOCAL_REL = '' unless defined ($LOCAL_REL);
    $GM_REL = '' unless defined ($GM_REL);

	if ($REMOTE_REL eq '') {
		$config->{$LOCAL_REL} = $GM_REL;
		next;
	}

    $LOCAL_REL = $REMOTE_REL unless ($LOCAL_REL ne '');
	$GM_REL = $REMOTE_REL unless ($GM_REL ne '');

	my $remotePath = catfile($config->{REMOTE_DIR}, $REMOTE_REL);
	my $localPath = catfile($config->{LOCAL_DIR}, $LOCAL_REL);
	my $mediaPath = join('/', grep {$_} $config->{GM_DIR}, $GM_REL);

	die "$myName: '$childPrefix$fnList' does not define REMOTE_BASE_URL\n" if not defined $config->{REMOTE_BASE_URL};

	next if catfile(cwd, $localPath) =~ /\Q$treeFilter\E(?:\/.+)?$/; # Skip items outside the tree we were run in

	if (-e $localPath) {
		unless (-d $localPath) {
			# Flag non-dirs that block repos
			print STDERR "ERROR: '$childPrefix$localPath' is not a directory\n";
			next;
		}

		# Don't touch non-repo dirs with a bargepole
		unless (&is_dir_repo_root($localPath)) {
			print STDERR "ERROR: '$childPrefix$localPath' is not a Git repository\n";
			next;
		}

		# Don't clone but do update remote & GM config
		print STDERR "'$childPrefix$localPath' exists\n";
		unless (
			&repo_set_remote($localPath, "$config->{REMOTE_BASE_URL}/$remotePath")
		and	&repo_config($localPath, $mediaPath)) {
			die "$myName: configuration failed for '$childPrefix$localPath'\n";
		}
	}
	else {
		# We need to configure GM after clone but before checkout, thus the three steps
		unless (
			&repo_clone_nocheckout($localPath, "$config->{REMOTE_BASE_URL}/$remotePath")
		and	&repo_config($localPath, $mediaPath)
		and	&repo_check_out($localPath)) {
			die "$myName: cloning, configuration, or checkout failed for '$childPrefix$localPath'\n";
		}
	}
}

&recurse($treeFilter) if $config->{OPT_RECURSE};

exit 0;

########################################################################################################################

sub chdir_find_listfile {
	until (-e $fnList) {
		my $prev = cwd;
		die "$myName: no '$childPrefix$fnList' file found in current directory or any ancestor\n" unless chdir('..') and cwd ne $prev;
	}
}

sub is_dir_repo_root {
	my ($localPath) = @_;

	my $prefix = `cd "$localPath" && git rev-parse --show-prefix`;
	chomp $prefix;
	return $prefix eq '';
}

sub repo_clone_nocheckout {
	my ($localPath, $remotePath) = @_;
	return not system qq!git clone --no-checkout "$remotePath" "$localPath" 1>&2!;
}

sub repo_config {
    my ($repoPath, $mediaPath) = @_;
	$mediaPath = '' unless defined $mediaPath;
	return not ($config->{CONFIG_CMD} and system qq!cd "$repoPath" && $config->{CONFIG_CMD} "$mediaPath" 1>&2!);
}

sub repo_check_out {
	my ($localPath) = @_;
	return not system qq!cd "$localPath" && git reset --hard 1>&2!;
}

sub repo_set_remote {
	my ($localPath, $remotePath) = @_;
	return not system qq!cd "$localPath" && git remote set-url origin "$remotePath" 1>&2!;
}

sub recurse {
    my ($dir) = @_;
	$dir =~ s/\/$//; # Remove any trailing slash before concatenating

	die "$myName: cannot open directory '$dir'\n"
		unless opendir(my $handle, $dir);

	my @kids = readdir($handle);

	foreach my $kid (@kids) {
		my $kidPath = "$dir/$kid";
		next if (not -d $kidPath);

		next if $kid eq "." or $kid eq ".." or $kid =~ /.git$/;

		if (-e "$kidPath/$fnList") { # Subdirs containing listfiles need recursive invocation
			my $kidPathRel  =  $kidPath =~ s/^$treeFilter\///r;

			system qq!cd "$kidPath" && GMC_RECURSE_PREFIX="$kidPathRel/" "$myPath"!;
			next; # Recursion will have found any deeper listfiles, so bail on this dir
		}

		&recurse($kidPath);
	}

	closedir($handle);
}