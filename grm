#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Cwd qw(cwd getcwd);

our $myPath = $0;
our $myName = basename($myPath);

our $fnList = '.remotes';

our $childPrefix = $ENV{'GMC_RECURSE_PREFIX'} // '';

use constant MODE_LIST => qw(
	clone
	set-remote
	configure
	list-rrel
	list-rurl
	list-lrel
	run
);

use constant MODE_LIST_LS => join("\n", MODE_LIST);

our $config = {
	OPT_RECURSE => 1,
	OPT_DEBUG_PRIMITIVES => 0,
	CONFIG_CMD => '',
	REMOTE_DIR => '',
	LOCAL_DIR => '.',
	GM_DIR => undef,
};

# Process the one and only possible command-line arg
die "$myName: too many arguments\n" unless scalar @ARGV <= 1;
&mode_set(shift @ARGV);

our $treeFilter = cwd; # Save current directory so we can use it later
&chdir_find_listfile;  # Change to the nearest ancestor dir containing a listfile

print STDERR "  Using list file '$childPrefix$fnList'\n"
	if $config->{OPT_DEBUG_PRIMITIVES};

open (my $fh, '<', $fnList) or exit 0;
while (<$fh>){
	next unless defined (my $result = parse_line($_));
    my ($REMOTE_REL, $LOCAL_REL, $GM_REL) = @{$result};

	unless ($REMOTE_REL) {
		$config->{$LOCAL_REL} = $GM_REL;
		next;
	}

    $LOCAL_REL = $REMOTE_REL unless $LOCAL_REL;
	$GM_REL = $REMOTE_REL unless $GM_REL;

	my $remotePath = &cat_path($config->{REMOTE_DIR}, $REMOTE_REL);
	my $localPath  = &cat_path($config->{LOCAL_DIR }, $LOCAL_REL );
	my $mediaPath  = &cat_path($config->{GM_DIR    }, $GM_REL    );

	die "$myName: '$childPrefix$fnList' does not define REMOTE_BASE_URL\n"
		unless defined $config->{REMOTE_BASE_URL};

	&repo_process($localPath, $remotePath, $mediaPath)
		if catfile(cwd, $localPath) =~ /\Q$treeFilter\E(?:\/.+)?$/; # Skip items outside the tree we were run in
}

&recurse($treeFilter) if $config->{OPT_RECURSE};

exit 0;

########################################################################################################################

sub cat_path {
	my @pieces = grep {defined $_ and $_ ne ''} @_;

	my $result = undef;
	for my $piece (reverse @pieces) {
		$piece =~ s/^\.\///;
		if (not defined $result) {
			$result=$piece;
		}
		else {
			$result = "$piece/$result";
		}

		return $result if $piece =~ /^\//;
	}

	return $result;	
}

sub parse_line {
	my ($line) = @_;

	chomp $line;

	$line =~ s/#.*$//;        # Remove comments (can be suffix)
	return undef if $line =~ /^\s*$/; # Skip lines of pure whitespace

	my @cols = split(':', $line, 3); # Split into (max) 3 cols
	$#cols = 2; # Pad to 3 cols with undefs
	return [map { ($_ // '') =~ s/^\s+|\s+$//gr } @cols]; # Each field: replace undef with empty then whitespace-trim
}

sub chdir_find_listfile {
	printf STDERR "  chdir_find_listfile: starting at '%s'\n", cwd
		if $config->{OPT_DEBUG_PRIMITIVES};

	until (-e $fnList) {
		my $prev = cwd;

		die "$myName: no '$childPrefix$fnList' file found in current directory or any ancestor\n"
			unless chdir('..') and cwd ne $prev;
	}
}

sub is_dir_repo_root {
	my ($localPath) = @_;

	my $prefix = `cd "$localPath" && git rev-parse --show-prefix`;

	die "$myName: is_dir_repo_root failed\n"
		if $?;

	chomp $prefix;
	return $prefix eq '';
}

sub mode_set {
	my ($mode) = @_;

	die "$myName: missing mode\n" if not defined($mode) or $mode eq '';
	die "$myName: no such mode '$mode'; must be one of:\n${\MODE_LIST_LS}\n" unless grep(/^$mode$/, MODE_LIST);

	$config->{MODE} = $mode;

	if ($mode eq 'run') {
		$config->{MODE_CLONE     } = 1;
		$config->{MODE_SET_REMOTE} = 1;
	}
	else {
		$config->{MODE_CLONE     } = $mode eq       'clone';
		$config->{MODE_SET_REMOTE} = $mode eq  'set-remote';
		$config->{MODE_CONFIGURE } = $mode eq   'configure';
		$config->{MODE_LIST_RREL } = $mode eq   'list-rrel';
		$config->{MODE_LIST_RURL } = $mode eq   'list-rurl';
		$config->{MODE_LIST_LREL } = $mode eq   'list-lrel';
	}

	$config->{MODE_CONFIGURE} ||= $config->{MODE_CLONE}; # Cloning requires configuration as phase 2/3, before checkout
}

sub repo_process {
	my ($localPath, $remotePath, $mediaPath) = @_;

	my $remoteURL = "$config->{REMOTE_BASE_URL}/$remotePath";

	# These return in order to maximise speed
	return print "$remotePath\n"            if $config->{MODE_LIST_RREL};
	return print "$remoteURL\n"             if $config->{MODE_LIST_RURL};
	return print "$childPrefix$localPath\n" if $config->{MODE_LIST_LREL};

	print STDERR "  repo_process: '$childPrefix$localPath'\n"
		if $config->{OPT_DEBUG_PRIMITIVES};

	unless (-e $localPath) {
		# We need to configure after clone but before checkout, thus the three steps
		&repo_clone_nocheckout($localPath, $remoteURL);
		&repo_config($localPath, $mediaPath);
		&repo_check_out($localPath);
		return;
	}

	unless (-d $localPath) {
		# Flag non-dirs that block repos
		print STDERR "ERROR: '$childPrefix$localPath' is not a directory\n";
		return;
	}

	# Don't touch non-repo dirs with a bargepole
	unless (&is_dir_repo_root($localPath)) {
		print STDERR "ERROR: '$childPrefix$localPath' is not a Git repository\n";
		return;
	}

	# For existing repos, don't clone but do update remote & configure
	print STDERR "'$childPrefix$localPath' exists\n";
	&repo_set_remote($localPath, $remoteURL);
	&repo_config($localPath, $mediaPath);
}

sub repo_clone_nocheckout {
	return unless $config->{MODE_CLONE};

	my ($localPath, $remotePath) = @_;

	print STDERR "  repo_clone_nocheckout: '$childPrefix$localPath'\n"
		if $config->{OPT_DEBUG_PRIMITIVES};

	die "$myName: repo_clone_nocheckout failed\n"
		if system qq!git clone --no-checkout "$remotePath" "$localPath" 1>&2!;
}

sub repo_config {
	return unless $config->{MODE_CONFIGURE} and $config->{CONFIG_CMD};

    my ($localPath, $mediaPath) = @_;

	$mediaPath = '' unless defined $mediaPath;

	print STDERR "  repo_config: '$childPrefix$localPath' with '$mediaPath'\n"
		if $config->{OPT_DEBUG_PRIMITIVES};

	die "$myName: repo_config failed\n"
		if system qq!cd "$localPath" && $config->{CONFIG_CMD} "$mediaPath" 1>&2!;
}

sub repo_check_out {
	return unless $config->{MODE_CLONE}; # Checkout is the last phase of cloning

	my ($localPath) = @_;

	print STDERR "  repo_check_out: '$childPrefix$localPath'\n"
		if $config->{OPT_DEBUG_PRIMITIVES};

	die "$myName: repo_check_out failed\n"
		if system qq!cd "$localPath" && git reset --hard 1>&2!;
}

sub repo_set_remote {
	return unless $config->{MODE_SET_REMOTE};

	my ($localPath, $remotePath) = @_;

	print STDERR "  repo_set_remote: '$childPrefix$localPath'\n"
		if $config->{OPT_DEBUG_PRIMITIVES};

	die "$myName: repo_set_remote failed\n"
		if system qq!cd "$localPath" && git remote set-url origin "$remotePath" 1>&2!;
}

sub recurse {
	return unless $config->{OPT_RECURSE};

    my ($dir) = @_;
	$dir =~ s/\/$//; # Remove any trailing slash before concatenating

	die "$myName: recursion to '${\cat_path($childPrefix, $dir)}' failed\n"
		unless opendir(my $handle, $dir);

	my @kids = readdir($handle);

	foreach my $kid (@kids) {
		my $kidPath = cat_path($dir, $kid);
		next if (not -d $kidPath);

		next if $kid =~ /^\./;

		if (-e "$kidPath/$fnList") { # Subdirs containing listfiles need recursive invocation
			my $kidPathRel  =  $kidPath =~ s/^$treeFilter\///r;

			system qq!cd "$kidPath" && GMC_RECURSE_PREFIX="$kidPathRel/" "$myPath" "$config->{MODE}"!;
			next; # Recursion will have found any deeper listfiles, so bail on this dir
		}

		&recurse($kidPath);
	}

	closedir($handle);
}